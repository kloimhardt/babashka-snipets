<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Inline Evaluation Adventure</title>

        <link rel="stylesheet" href="https://rigsomelight.com/css/syntax.css">

        <link rel="stylesheet" href="https://rigsomelight.com/assets/bootstrap/css/bootstrap.css">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="alternate" type="application/rss+xml" title="Rig Some Light Feed" href="http://rigsomelight.com/feed.xml">

        <link rel="stylesheet" href="https://rigsomelight.com/assets/css/style.css">
	
	      <link rel="stylesheet" href="https://rigsomelight.com/assets/inline-edit/css/style.css">
	
    </head>
    <body>

        <div class="container">
          <div class="site">
            
            <ul class="breadcrumb">
              <li class="active"><a href="/">Bruce Hauman</a></li>
              <li class="active"><a href="/bruce_hauman.html">About Me</a></li>	      
            </ul>

                <h2>Inline Evaluation Adventure</h2>

<p class="meta">12 Mar 2025</p>

<div class="post">
<p>Inline evaluation has been around for a long time, but not every
programmer has had the chance to use it. If you haven’t, this is an
opportunity to try it.</p>

<p>To this end I’ve coded up a simple editor with some code examples. The
following examples are all editable and executable, however no <strong>run</strong>
button exists to execute them. You’ll use <code class="language-plaintext highlighter-rouge">Control-r</code> to
<em>RUN/EVALUATE</em> pieces of code that you select from inside the editor
panes below.</p>

<p>To see it in action, place your cursor immediately after the
expression you want to evaluate in the editor below. Then, press
<code class="language-plaintext highlighter-rouge">Control-r</code> (hold the <code class="language-plaintext highlighter-rouge">Control</code> key down while pressing the <code class="language-plaintext highlighter-rouge">r</code>
key). For example, if you want to evaluate <code class="language-plaintext highlighter-rouge">(+ 1 2 3)</code>, position the
cursor after the closing parenthesis <code class="language-plaintext highlighter-rouge">)</code> and then press
<code class="language-plaintext highlighter-rouge">Control-r</code>. For brevity, <em>we’ll be using <code class="language-plaintext highlighter-rouge">^r</code> as shorthand for
<code class="language-plaintext highlighter-rouge">Control-r</code> from now on.</em></p>

<div class="cljs-editor-new"><pre>1
;`-- Place cursor after 1 then hit ^r

"Gremlins are cuties!"
;                     `-- Place cursor after " then hit ^r

(+ 1 2 3)
;   `-- Place cursor after 1 then hit ^r

(+ 1 2 3)
;        `-- Place cursor after the ')' then hit ^r

(+ 1 (/ 8 2) (* 2 3) )
;           `-------`-` Place cursor after each ')' and then hit ^r

(+ 1
   (/ 8 2)
   (* 2 3))
;          `-- Place cursor after ')' and then hit ^r

 
;`-- Place cursor above this line and hit ^r
</pre></div>

<p>When you pressed <code class="language-plaintext highlighter-rouge">^r</code>, the editor found the closest preceding complete
expression and sent it it to a runtime session (REPL) for
evaluation. The result then appeared right next to your code, exactly
where you were already looking. No context change needed to see the
code run.</p>

<p>You may have noticed that you can evaluate smaller parts of an
expression, like <code class="language-plaintext highlighter-rouge">(/ 8 2)</code>, just as easily as a full expression. You
can also evaluate expressions that span multiple lines.</p>

<blockquote>
  <p>Lisp languages make it simple to write editor tools that can do
this. It is trivial to write an editor plugin to detect an
expression delimited by parenthesis.</p>
</blockquote>

<p>Sometimes, when I’m uncertain about function names or behavior,
instead of searching for them, I simply try evaluating them inline to
see if they exist and if they behave the way I expect them to.</p>

<p>For example, I know I created a function that renders HTML into a
<code class="language-plaintext highlighter-rouge">div</code> above the editor, but I can’t remember if it’s called
<code class="language-plaintext highlighter-rouge">show-html</code> or <code class="language-plaintext highlighter-rouge">display-html</code>. Let’s evaluate both of the expressions
below to see which one works:</p>

<div class="cljs-editor-new"><pre>
;; was it show-html or display-html??
(show-html "&lt;h1&gt;It's in a DIV!&lt;/h1&gt;")
;;                                   `-- ^r eval here

(display-html "&lt;h1&gt;It's in a DIV!&lt;/h1&gt;")
;;                                      `-- ^r eval here
</pre></div>

<p>With inline evaluation, I can quickly discover which function is
defined <strong>and</strong> if it does what I expect, all without leaving the
editor or breaking my flow.</p>

<p>In the next example, let’s apply this same approach to discover what
the <code class="language-plaintext highlighter-rouge">look</code>, <code class="language-plaintext highlighter-rouge">move</code> and <code class="language-plaintext highlighter-rouge">reset</code> functions do.</p>

<blockquote>
  <p><em>In all examples that follow, try evaluating each expression with <code class="language-plaintext highlighter-rouge">^r</code>
to see the results.</em></p>
</blockquote>

<div class="cljs-editor-new"><pre>
(look)

(move :east)

(reset)


</pre></div>

<p>Notice how the <code class="language-plaintext highlighter-rouge">look</code> function returns data describing your location
in a text adventure game, while the <code class="language-plaintext highlighter-rouge">move</code> function lets you navigate
through this virtual world.</p>

<p>This provides an opportunity to demonstrate how inline evaluation
helps us build and refine code incrementally.</p>

<p>Evaluating <code class="language-plaintext highlighter-rouge">(look)</code> and <code class="language-plaintext highlighter-rouge">(move :east)</code> could work as a spartan interface to the
game, but it would definitely be better to display this data using our
<code class="language-plaintext highlighter-rouge">display-html</code> function. Right? Right??</p>

<p>Now if we examine the data that the <code class="language-plaintext highlighter-rouge">look</code> function returns we can
see that it’s returning a <strong>hash map</strong> of some sort, with the keys
<code class="language-plaintext highlighter-rouge">:desc</code>, <code class="language-plaintext highlighter-rouge">:seen</code>, <code class="language-plaintext highlighter-rouge">:exit</code> and so on. Each of these keys map to
<strong>string</strong> descriptions of the state of the game.</p>

<p>Let’s work on formatting the data returned by <code class="language-plaintext highlighter-rouge">look</code> into some HTML
that we can display.</p>

<div class="cljs-editor-new"><pre>
;; First lets see what data is returned
(look)

;; I see a :desc key that holds a description 
(get (look) :desc)

;; OK we have a description let's put that into an HTML string
(str "&lt;p&gt;" (get (look) :desc) "&lt;/p&gt;")

;; Now let's display that HTML
(display-html (str "&lt;p&gt;" (get (look) :desc) "&lt;/p&gt;"))
</pre></div>

<p>Let’s improve our code by breaking out that paragraph tag into its own
function:</p>

<div class="cljs-editor-new" data-sci-ctx="main-game"><pre>
;; Evaluate this to define the paragraph function
(defn p [content] 
  (str "&lt;p&gt;" content "&lt;/p&gt;"))

;; now let's see how it works
(p "Hello")

(display-html (p (get (look) :desc)))
</pre></div>

<p>OK, now we are getting somewhere. But we also have to format the
things that are <code class="language-plaintext highlighter-rouge">:seen</code> in the room:</p>

<div class="cljs-editor-new" data-sci-ctx="main-game"><pre>
(look)

;; Let's extract the :seen items
(get (look) :seen)

;; Add some context to the raw data
(str "You see: " (get (look) :seen))

;; put it in a paragraph
(p (str "You see: " (get (look) :seen)))

;; let's add the :desc and the :seen together
(str
  (p (get (look) :desc))
  (p (str "You see: " (get (look) :seen))))
 
;; then display it
(display-html
  (str
    (p (get (look) :desc))
    (p (str "You see: " (get (look) :seen)))))
		
</pre></div>

<p>So we’re building up some code to format the the data returned from the
<code class="language-plaintext highlighter-rouge">look</code> function as HTML.</p>

<p>So let’s put this code in a function and start working on the function
instead of just composing expressions.</p>

<div class="cljs-editor-new" data-sci-ctx="main-game"><pre>
;; so here's our initial format function
(defn look-html [data]
  (str
    (p (get data :desc))
    (p (str "You see: " (get data :seen)))))

;; let's see if it's working
(look-html (look))

;; and finally
(display-html (look-html (look)))

</pre></div>

<p>OK now we have a <code class="language-plaintext highlighter-rouge">look-html</code> function which we can re-use, but there
is definitely room for improvement.  If we look at the data that’s
returned by the <code class="language-plaintext highlighter-rouge">look</code> function you can see that there is also an
<code class="language-plaintext highlighter-rouge">:img-path</code>. Let’s use that to add more visual interest to our game
display.</p>

<div class="cljs-editor-new" data-sci-ctx="main-game"><pre>
;; let's build up an expression to format the :img-path as 
;; an img tag
(get (look) :img-path)
(str "&lt;img src='" (get (look) :img-path) "'/&gt;")

;; let's insert the image tag into our look-html function
(defn look-html [data]
  (str
    ;; v-- added img here --v
    (str "&lt;img src='" (get data :img-path) "'/&gt;")
    (p (get data :desc))
    (p (str "You see: " (get data :seen)))))

;; let's see if it's working
(look-html (look))

;; and let's take a look!
(display-html (look-html (look)))

</pre></div>

<p>Not bad at all. OK, now we only have one more piece of information
left to add to our <code class="language-plaintext highlighter-rouge">look-html</code> function. When you evaluate the
<code class="language-plaintext highlighter-rouge">(look)</code> function you will notice an <code class="language-plaintext highlighter-rouge">:exits</code> entry which gives the
player clues about which directions they can move from their current
location.</p>

<p>I think we are at the point where you can add the <code class="language-plaintext highlighter-rouge">:exits</code> info to the
<code class="language-plaintext highlighter-rouge">look-html</code> function.</p>

<div class="cljs-editor-new" data-sci-ctx="main-game"><pre>
;; here's the :exits data
(get (look) :exits)

;; Add the exits data to the function below:
(defn look-html [data]
  (str
    (str "&lt;img src='" (get data :img-path) "'/&gt;")
    (p (get data :desc))
    (p (str "You see: " (get data :seen)))
    (p (str "Exits: "    ))))

;; test it out here to see if it's working
(look-html (look))

;; and finally take a look!
(display-html (look-html (look)))

</pre></div>

<h3 id="do-you-want-to-play-a-game">Do you want to play a game?</h3>

<p>Now that we’ve built our <code class="language-plaintext highlighter-rouge">look-html</code> function, let’s use inline
evaluation to explore the text adventure.</p>

<p>Below are several game interaction functions. Using the inline
evaluation, evaluate each one to discover its purpose and effect on
the game state. This demonstrates how inline evaluation serves as both
a development <strong>and</strong> exploration tool.</p>

<div class="cljs-editor-new" data-sci-ctx="main-game" data-cljs-editor-focus-hook="ensure-fns"><pre>
(display-html (look-html (look)))
(move :east)

(stack)
(push :picture)
(peek)
(pop)

(unlock-function :_something?_)
(reset)
</pre></div>

<p>Don’t be afraid to enhance the UI. Here are some suggestions:</p>
<ul>
  <li>Create a <code class="language-plaintext highlighter-rouge">looki</code> function that combines our <code class="language-plaintext highlighter-rouge">display-html</code> and <code class="language-plaintext highlighter-rouge">look-html</code> functions: <code class="language-plaintext highlighter-rouge">(display-html (look-html (look)))</code></li>
  <li>Develop a <code class="language-plaintext highlighter-rouge">movi</code> function that calls <code class="language-plaintext highlighter-rouge">move</code> and then <code class="language-plaintext highlighter-rouge">looki</code> to show the new location</li>
  <li>Extend your <code class="language-plaintext highlighter-rouge">look-html</code> function to display the <code class="language-plaintext highlighter-rouge">(stack)</code> information</li>
  <li>your own images, there’s nothing stopping you from creating your own
images and using those in the game</li>
</ul>

<h3 id="and-end">And end?</h3>

<p>Thanks for taking the time to experience inline evaluation.</p>

<p>As programmers, we often fall into cognitive ruts that constrain
our expectations of what the programming process can be. These mental
ruts, in turn, limit the potential of what we create. I have observed
decisions by language designers, programming architecture advocates,
and tool builders that directly ignore or impede this type of
interactivity—a situation I find genuinely unfortunate.</p>

<p>It’s hard to get people to try things outside their experience. It’s
natural to resist unfamiliar ideas and dismiss them. Many who read
this will likely respond by arguing that this kind of interactivity
isn’t necessary or useful. However, in my humble opinion, that simply
isn’t true.</p>

<p>Yes, these may be toy examples inside a toy editor, but this level of
interactivity is very real. Clojure programmers—and others who use
similar evaluation capabilities—apply this technique daily in
professional settings, from data pipelines powering major retailers to
the video streaming services you likely use yourself.</p>

<p>My argument isn’t that Clojure or Lisp is inherently superior to other
languages, but that inline evaluation is incredibly valuable and
deserves wider adoption across programming environments.</p>

<p>By experiencing it firsthand, you might be inspired to expect more
from your programming languages and tools—or even create your own.</p>

</div>


    


            <div class="footer">
              <div class="contact">
                <p>
                  <a href="/bruce_hauman.html">Bruce Hauman</a><br />
                  Programmer<br />
                  bhauman@gmail.com
                </p>
              </div>
	      <div class="contact">
		<p>
		  <a href="/bruce_hauman.html">About</a>
		</p>  
	      </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/bhauman/">github.com/bhauman</a><br />
		  <a href="https://www.linkedin.com/in/bruce-hauman-bb6958129">linkedin</a><br />
		  <a rel="me" href="https://functional.cafe/@bhauman">Mastodon</a><br/>
                  <a href="/feed.xml">blog feed</a>

                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->
	
	
	      <script src="https://rigsomelight.com/assets/inline-edit/main.js"></script>
	
    </body>
</html>
